#ifndef FILTER_H
#define FILTER_H

#include <iostream>
#include <string>
#include <list>
#include <map>
#include <sstream>
#include <iterator>

#include "mat.h"
#include "common.h"
#include "change_tracking_list.h"

#include "filter_val.h"
#include "filter_input.h"

#include "sgnode.h"
#include "soar_interface.h"


class filter_output : 
  public change_tracking_list<filter_val>, public sgnode_listener
{
  public:
    void node_update(sgnode *n, sgnode::change_type t, const std::string& update_info);

    virtual void add(filter_val* v);

    virtual void remove(filter_val* v);

    virtual void clear();

  protected:
    typedef std::map<sgnode*, const filter_val*> node_filter_val_map;
    node_filter_val_map node_map;
};


/*
 Every filter generates a list of filter values as output, even if
 the list is empty or a singleton.
*/
//typedef change_tracking_list<filter_val> filter_output;

/*
 A filter parameter set represents one complete input into a filter. It's
 just a list of pairs <parameter name, value>.
*/
typedef std::vector<std::pair<std::string, filter_val*> > filter_params;

/*
 The filter is the basic query unit in SVS. Each filter takes a list of
 parameter sets generated by the filter_input class and produces a single
 output list. Soar can "mix-and-match" filters by plugging their outputs
 into inputs of other filters. This is done by specifying the desired
 filter plumbing on the SVS command link.
 
 Filter outputs are updated once every output phase. Updating a filter's
 output is recursive: the filter will first request an update on its
 input, which in turn requests updates on all filters feeding into the
 input. Filters should also try to cache outputs when possible to avoid
 unnecessary computation.
*/
class filter {
public:

	filter(Symbol *root, soar_interface *si, filter_input *in);

	virtual ~filter();
	
	void set_status(const std::string &msg);
	
	void add_output(filter_val *v, const filter_params *p);
	void get_output_params(filter_val *v, const filter_params *&p);
	void remove_output(filter_val *v);
	void change_output(filter_val *v);
	bool update();

//TODO slightly less ugly hack
	virtual int getAxis()
	{
	    return -3;
	}
	
	virtual int getComp()
	{
	    return -3;
	}
	
	filter_output* get_output()                        { return &output;     }
	const filter_input *get_input() const              { return input;       }
	void listen_for_input(filter_input::listener *l)   { input->listen(l);   }
	void unlisten_for_input(filter_input::listener *l) { input->unlisten(l); }
	void mark_stale(const filter_params *s)            { input->change(s);   }

private:
	virtual bool update_outputs() = 0;
	
	filter_input *input;
	filter_output output;
	std::string status;
	soar_interface *si;
	Symbol *root;
	wme *status_wme;
	std::map<filter_val*, const filter_params*> output2params;
};

/*
 This type of filter assumes a one-to-one mapping of outputs to input
 parameter sets. It's also assumed that each output is only dependent
 on one parameter set. This is in contrast to filters that perform some
 kind of quantification over its inputs; returning the closest object,
 for example.
*/
class map_filter : public filter {
public:
	map_filter(Symbol *root, soar_interface *si, filter_input *input);
	
	/*
	 All created filter_vals are owned by the output list and cleaned
	 up there, so don't do it here.
	*/
	virtual ~map_filter() {}
	
	/*
	 Compute the output from parameters. If called with a new
	 parameter set, out will be NULL, and the implementation should
	 set it to a new filter_val object (which will be owned by the
	 output list). Otherwise, out will point to a valid filter_val and
	 the implementation should change its value. If the value is
	 actually changed, the changed output argument should be set to
	 true. The implementation should return false if an error occurs.
	 */
	virtual bool compute(const filter_params *params, filter_val *&out, bool &changed) = 0;
	
	/*
	 Some derived classes might allocate memory associated with each
	 output. They should override this function so they know when
	 to deallocate that memory.
	*/
	virtual void output_removed(const filter_val *out) { }
	
	bool update_outputs();
	void reset();

private:
	bool update_one(const filter_params *params);
	
	typedef std::map<const filter_params*, filter_val*> io_map_t;
	io_map_t io_map;
	std::vector<const filter_params*> stale;
};

/*
 User-defined filters should derive from this class so that they don't
 have to work with filter_val* directly. Assumes that the filter only
 returns one type of output.
*/
template <class T>
class typed_map_filter : public map_filter {
public:
	typed_map_filter(Symbol *root, soar_interface *si, filter_input *input)
	: map_filter(root, si, input)
	{}
	
	virtual ~typed_map_filter() {}
	
	virtual bool compute(const filter_params *params, bool adding, T &out, bool &changed) = 0;
	virtual void output_removed(const T &out) { }
	
private:
	bool compute(const filter_params *params, filter_val *&out, bool &changed);

	void output_removed(const filter_val *out);
};


/* select_filter
   This filter is very similar to a map filter
   It takes a list of inputs, and for each input it does a computation and possibly
     creates an output if some conditions are met.
     Thus the number of outputs is at most the number of inputs
   For example, an intersection filter based on the select_filter would return a list of 
	nodes that intersect the target instead of producing T/F values for every node
   This is useful for feeding in a subset of the all_nodes filter into another filter
   A filter based on the select_filter is the has_property filter
*/
class select_filter : public filter{
public:
	select_filter(Symbol *root, soar_interface *si, filter_input *input)
	: filter(root, si, input)
	{}

	virtual ~select_filter(){}

	// This is the main function to implement in the derived class
        // out is the output value to create, leave it NULL to avoid adding it to the output
        // changed should be true if the value changed
  	// The function returns true if successful, false if an error occurred
	// To see a sample implementation, see the has_property filter
	virtual bool compute(const filter_params *params, filter_val*& out, bool& changed) = 0;

	bool update_outputs();

	// Override this if you need to take care of memory when an output is removed
	virtual void output_removed(filter_val* out) { }

private:
	bool update_one(const filter_params *params);

	typedef std::map<const filter_params*, filter_val*> io_map_t;
	io_map_t io_map;

	void reset() {
		io_map.clear();
	}
};

/*
 User-defined filters should derive from this class so that they don't
 have to work with filter_val* directly. Assumes that the filter only
 returns one type of output.
*/
template <class T>
class typed_select_filter : public select_filter {
public:
	typed_select_filter(Symbol *root, soar_interface *si, filter_input *input)
	: select_filter(root, si, input)
	{}

	virtual ~typed_select_filter() {}

	// How to implement:
	// params - a set of parameters chosen from the inputs
	// null_out - true if the given out variable holds junk
	// out - the result of the computation
	// select - if true, the given out value will be added to the output, if false it will not be passed on
	// changed - use to indicate whether the out value changed
	virtual bool compute(const filter_params *params, bool null_out, T &out, bool& select, bool& changed) = 0;

	virtual void output_removed(const T &out) { }

private:
	bool compute(const filter_params *params, filter_val *&out, bool &changed);

	void output_removed(const filter_val *out);
};


/*
 This type of filter processes all inputs and produces a single
 output. 
*/
template<typename T>
class reduce_filter : public filter {
public:
	reduce_filter(Symbol *root, soar_interface *si, filter_input *input)
	: filter(root, si, input), output(NULL)
	{}
	
	virtual ~reduce_filter() {}
	
	bool update_outputs();
	
private:
	virtual bool input_added(const filter_params *params) = 0;
	virtual bool input_changed(const filter_params *params) = 0;
	virtual bool input_removed(const filter_params *params) = 0;
	virtual bool calculate_value(T &val) = 0;
	
	filter_val_c<T> *output;
	T value;
};

class rank_filter : public filter {
public:
	rank_filter(Symbol *root, soar_interface *si, filter_input *input)
	: filter(root, si, input), output(NULL), old(NULL)
	{}

	virtual bool rank(const filter_params *params, double &r) = 0;

private:
	bool update_outputs();

	std::vector<std::pair<double, const filter_params*> > elems;
	filter_val *output;
	const filter_params *old;
};

/*
 Filters that don't take any inputs and always outputs the same value
*/
template <class T>
class const_filter : public filter {
public:
	const_filter(const T &v) : filter(NULL, NULL, NULL), added(false), v(v) {}
	
	bool update_outputs();
		
private:
	T v;
	bool added;
};

/*
 Passes an arbitrary element in each input parameter set to the output
 list. This filter is intended to be used with concat_filter_input to
 implement a "combine" filter that multiplexes an arbitrary number of
 inputs into a single list.
*/
class passthru_filter : public map_filter {
public:
	passthru_filter(Symbol *root, soar_interface *si, filter_input *input)
	: map_filter(root, si, input)
	{}
	
	bool compute(const filter_params *params, filter_val *&out, bool &changed);
};

template <typename T>
inline bool get_filter_param(filter *f, const filter_params *params, const std::string &name, T &val) {
	const filter_val *fv;
	std::stringstream ss;
	filter_params::const_iterator i;
	bool found = false;
	for (i = params->begin(); i != params->end(); ++i) {
		if (i->first == name) {
			fv = i->second;
			found = true;
			break;
		}
	}
	if (!found) {
		return false;
	}
	if (!get_filter_val(fv, val)) {
		if (f) {
			ss << "parameter \"" << name << "\" has wrong type";
			f->set_status(ss.str());
		}
		return false;
	}
	return true;
}

#endif
