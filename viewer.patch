diff -crb viewer/Visual Studio 2010/Application.vcxproj.user SVS Viewer/Visual Studio 2010/Application.vcxproj.user
*** viewer/Visual Studio 2010/Application.vcxproj.user	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/Visual Studio 2010/Application.vcxproj.user	2012-07-12 11:24:35.000000000 -0400
***************
*** 24,30 ****
      <LocalDebuggerCommand>$(SolutionDir)..\bin\$(ProjectName)_d.exe</LocalDebuggerCommand>
      <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
      <LocalDebuggerWorkingDirectory>..\bin</LocalDebuggerWorkingDirectory>
!     <LocalDebuggerCommandArguments>-s</LocalDebuggerCommandArguments>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      <LocalDebuggerCommand>$(SolutionDir)..\bin\x64\$(ProjectName)_d.exe</LocalDebuggerCommand>
--- 24,31 ----
      <LocalDebuggerCommand>$(SolutionDir)..\bin\$(ProjectName)_d.exe</LocalDebuggerCommand>
      <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
      <LocalDebuggerWorkingDirectory>..\bin</LocalDebuggerWorkingDirectory>
!     <LocalDebuggerCommandArguments>
!     </LocalDebuggerCommandArguments>
    </PropertyGroup>
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      <LocalDebuggerCommand>$(SolutionDir)..\bin\x64\$(ProjectName)_d.exe</LocalDebuggerCommand>
Binary files viewer/Visual Studio 2010/Zenilib_2010.suo and SVS Viewer/Visual Studio 2010/Zenilib_2010.suo differ
Binary files viewer/bin/Application_d.exe and SVS Viewer/bin/Application_d.exe differ
Binary files viewer/bin/Application_d.ilk and SVS Viewer/bin/Application_d.ilk differ
Only in SVS Viewer/bin: qhull.dll
Only in SVS Viewer/bin: qhull.exe
diff -crb viewer/config/zenilib.xml SVS Viewer/config/zenilib.xml
*** viewer/config/zenilib.xml	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/config/zenilib.xml	2012-07-12 14:43:59.000000000 -0400
***************
*** 57,63 ****
          <Multisampling>0</Multisampling>
          <Resolution>
              <Width>640</Width>
!             <Height>480</Height>
          </Resolution>
          <Vertical_Sync>1</Vertical_Sync>
      </Video>
--- 57,63 ----
          <Multisampling>0</Multisampling>
          <Resolution>
              <Width>640</Width>
!             <Height>507</Height>
          </Resolution>
          <Vertical_Sync>1</Vertical_Sync>
      </Video>
diff -crb viewer/config/zenilib.xml.bak SVS Viewer/config/zenilib.xml.bak
*** viewer/config/zenilib.xml.bak	2012-07-05 12:33:49.000000000 -0400
--- SVS Viewer/config/zenilib.xml.bak	2012-07-12 14:43:59.000000000 -0400
***************
*** 57,63 ****
          <Multisampling>0</Multisampling>
          <Resolution>
              <Width>640</Width>
!             <Height>480</Height>
          </Resolution>
          <Vertical_Sync>1</Vertical_Sync>
      </Video>
--- 57,63 ----
          <Multisampling>0</Multisampling>
          <Resolution>
              <Width>640</Width>
!             <Height>507</Height>
          </Resolution>
          <Vertical_Sync>1</Vertical_Sync>
      </Video>
diff -crb viewer/src/SVSObject.cpp SVS Viewer/src/SVSObject.cpp
*** viewer/src/SVSObject.cpp	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSObject.cpp	2012-07-12 14:43:11.000000000 -0400
***************
*** 11,16 ****
--- 11,19 ----
  #include "SVSObject.h"
  
  #include <fstream>
+ #include <sstream>
+ 
+ const float SVSObject::global_scale = 50.0f;
  
  SVSObject::SVSObject(std::string name, const std::vector<Zeni::Point3f> verts, Zeni::Point3f position, Zeni::Quaternion rotation, Zeni::Point3f scale, SVSObject* parent)
  {	
***************
*** 28,33 ****
--- 31,43 ----
  		exit(1);
  	}
  
+ 	if (parent)
+ 	{
+ 		position.x *= parent->get_scale().x;
+ 		position.y *= parent->get_scale().x;
+ 		position.z *= parent->get_scale().x;
+ 	}
+ 	
  	if (verts.size() == 0)
  	{
  		is_group = true;
***************
*** 52,57 ****
--- 62,71 ----
  	
  	std::vector<std::vector<int> > faces = verts_for_faces(verts);
  
+ 	//WARNING Starcraft Specific
+ 	position.y *= -1;
+ 	scale.y *= -1;
+ 	
  	Zeni::Matrix4f local_transformation_matrix = Zeni::Matrix4f::Translate(position) * Zeni::Matrix4f::Rotate(rotation) * Zeni::Matrix4f::Scale(scale);
  	
  	std::cout << "Position: " << position.x << "," << position.y << "," << position.z << std::endl;
***************
*** 349,368 ****
  {
  	std::vector<std::vector<int> > faces;
  	
! #ifdef _WIN32
! 	char* temp_folder = new char[MAX_PATH+1];
! 	GetTempPath(MAX_PATH+1, temp_folder);
! #else
! 	std::string temp_folder = "/tmp/";
! #endif
  	
! 	std::string path = temp_folder;
! 	path += "qhull";
  	
  	std::ofstream to_output(path.c_str(), std::ofstream::out | std::ofstream::trunc);
  	
  	if (!to_output.is_open())
! 		return faces;
  	
  	to_output << "3" << std::endl << pts.size() << std::endl;
  	
--- 363,384 ----
  {
  	std::vector<std::vector<int> > faces;
  	
! //#ifdef _WIN32
! //	char* temp_folder = new char[MAX_PATH+1];
! //	GetTempPath(MAX_PATH+1, temp_folder);
! //#else
! //	std::string temp_folder = "/tmp/";
! //#endif
! //	
! //	std::string path = temp_folder;
! //	path += "qhull";
  
! 	std::string path = "C:\\qhull";
  	
  	std::ofstream to_output(path.c_str(), std::ofstream::out | std::ofstream::trunc);
  	
  	if (!to_output.is_open())
! 		throw Zeni::Error(("Unable to open qhull file: " + path).c_str());
  	
  	to_output << "3" << std::endl << pts.size() << std::endl;
  	
***************
*** 394,401 ****
  	if (!CreateProcess(NULL, command_line_char, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &start_info, &process_info))
  	{
  		std::cout << "Could not spawn qhull process!" << std::endl;
! 		return faces;
  	}
  #else
  	std::string command = "qhull ";
  	command += command_line;
--- 410,419 ----
  	if (!CreateProcess(NULL, command_line_char, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &start_info, &process_info))
  	{
  		std::cout << "Could not spawn qhull process!" << std::endl;
! 		throw Zeni::Error(("Unable spawn qhull at " + command_line).c_str());
  	}
+ 
+ 	DWORD exit_code = WaitForSingleObject(process_info.hProcess, INFINITE);
  #else
  	std::string command = "qhull ";
  	command += command_line;
***************
*** 412,441 ****
  	std::ifstream output(output_path.c_str(), std::ifstream::in);
  	
  	if (!output.is_open())
! 		return faces;
  	
  	std::string line;
! 	getline(output, line);
  	unsigned int nfacets = strtol(line.c_str(), &end, 10);
! 	if (*end != '\0') {
! 		return faces;
  	}
  
! 	bool should_not_break = false;
! 	
! 	while (getline(output, line)) {
! 		const char *start = line.c_str();
  		std::vector<int> facet;
! 		while (!should_not_break) {
! 			int x = strtol(start, &end, 10);
! 			if (end == start) {
  				break;
  			}
  			facet.push_back(x);
- 			start = end;
  		}
  		faces.push_back(facet);
  	}
  	assert (faces.size() == nfacets);
  	return faces;
  }
--- 430,469 ----
  	std::ifstream output(output_path.c_str(), std::ifstream::in);
  	
  	if (!output.is_open())
! 		throw Zeni::Error(("Unable to open qhull file: " + output_path).c_str());
  	
  	std::string line;
! 
! 	if (!getline(output, line))
! 		throw Zeni::Error("getline failed to get the first line of the file!");
! 
  	unsigned int nfacets = strtol(line.c_str(), &end, 10);
! 	if (*end != '\0' && *end != '\n') {
! 		throw Zeni::Error("File line doesn't contain null character");
  	}
  	
! 	while (getline(output, line))
! 	{
  		std::vector<int> facet;
! 
! 		std::istringstream iss(line, std::istringstream::in);
! 
! 		std::string number;
! 		while (iss >> number)
! 		{
! 			int x = strtol(number.c_str(), &end, 10);
! 			if (*end != '\0') {
  				break;
  			}
  			facet.push_back(x);
  		}
+ 		
  		faces.push_back(facet);
  	}
  	assert (faces.size() == nfacets);
+ 
+ 	if (faces.size() == 0)
+ 		throw Zeni::Error("Zero faces for a non-group!");
+ 
  	return faces;
  }
diff -crb viewer/src/SVSObject.h SVS Viewer/src/SVSObject.h
*** viewer/src/SVSObject.h	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSObject.h	2012-07-10 11:28:22.000000000 -0400
***************
*** 43,48 ****
--- 43,50 ----
  	
  	Zeni::Matrix4f get_transformation_matrix() { return transformation_matrix; }
  	
+ 	static const float global_scale;
+ 
  private:
  	static std::vector<std::vector<int> > verts_for_faces(const std::vector<Zeni::Point3f> verts);
  	
diff -crb viewer/src/SVSParser.cpp SVS Viewer/src/SVSParser.cpp
*** viewer/src/SVSParser.cpp	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSParser.cpp	2012-07-10 17:01:49.000000000 -0400
***************
*** 51,56 ****
--- 51,62 ----
  	std::string name = parts[0];
  	std::string parent_name;
  
+ 	if (parts.size() == 1 && name == "clear")
+ 	{
+ 		scene.clear_objects();
+ 		return true;
+ 	}
+ 	
  	if (parts.size() > 1)
  		parent_name = parts[1];
  	
***************
*** 99,105 ****
  				
  				Zeni::Quaternion* temp_quaternion;
  				
! 				temp_quaternion = new Zeni::Quaternion(temp_rotation.x, temp_rotation.y, temp_rotation.z);
  				
  				rotation = (*temp_quaternion);
  				
--- 105,111 ----
  				
  				Zeni::Quaternion* temp_quaternion;
  				
! 				temp_quaternion = new Zeni::Quaternion(temp_rotation.y, temp_rotation.x, temp_rotation.z);
  				
  				rotation = (*temp_quaternion);
  				
diff -crb viewer/src/SVSScene.cpp SVS Viewer/src/SVSScene.cpp
*** viewer/src/SVSScene.cpp	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSScene.cpp	2012-07-12 11:23:34.000000000 -0400
***************
*** 13,20 ****
  SVSScene::SVSScene(std::string name)
  {
  	scene_name = name;
! 	
! 	this->add_object("world", "", std::vector<Zeni::Point3f>(), Zeni::Point3f(), Zeni::Quaternion(), Zeni::Point3f(50,50,50));
  }
  
  SVSScene::SVSScene(const SVSScene &source)
--- 13,20 ----
  SVSScene::SVSScene(std::string name)
  {
  	scene_name = name;
! 	const float scale = SVSObject::global_scale;
! 	this->add_object("world", "", std::vector<Zeni::Point3f>(), Zeni::Point3f(), Zeni::Quaternion(), Zeni::Point3f(scale,scale,scale));
  }
  
  SVSScene::SVSScene(const SVSScene &source)
***************
*** 48,53 ****
--- 48,62 ----
  		delete objects[i];
  }
  
+ void SVSScene::clear_objects()
+ {
+ 	
+ 	 objects.clear();
+ 	 
+ 	 float scale = SVSObject::global_scale;
+ 	 add_object("world", "", std::vector<Zeni::Point3f>(), Zeni::Point3f(), Zeni::Quaternion(), Zeni::Point3f(scale,scale,scale)); 
+ }
+ 
  bool SVSScene::add_object(std::string name, std::string parent, std::vector<Zeni::Point3f> vertices, Zeni::Point3f position, Zeni::Quaternion rotation, Zeni::Point3f scale)
  {
  	for (unsigned int i = 0;i < objects.size();i++)
diff -crb viewer/src/SVSScene.h SVS Viewer/src/SVSScene.h
*** viewer/src/SVSScene.h	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSScene.h	2012-07-10 17:01:49.000000000 -0400
***************
*** 39,44 ****
--- 39,46 ----
  	void render();
  	void render_wireframe();
  
+ 	void clear_objects();
+ 	
  private:
  	std::string scene_name;
  	
diff -crb viewer/src/SVSSocket.cpp SVS Viewer/src/SVSSocket.cpp
*** viewer/src/SVSSocket.cpp	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSSocket.cpp	2012-07-10 17:01:49.000000000 -0400
***************
*** 10,15 ****
--- 10,20 ----
  
  #include "SVSSocket.h"
  
+ #include <iostream>
+ #include <fstream>
+ 
+ #include "SVSViewerState.h"
+ 
  //If we're not on windows
  #ifndef _WIN32
  const char* SVSSocket::default_path_pipe = "/tmp/viewer"; //Set this to the default path, /tmp/viewer
***************
*** 25,30 ****
--- 30,37 ----
  	if (strlen(path) == 0) //If we have an empty path,
  		path = default_path_pipe; //Set it to the default
  
+ 	standard_input = false;
+ 
  #ifndef _WIN32 //If we're not on windows
  	struct sockaddr_un address; //Create a variable for our unix socket
  
***************
*** 67,82 ****
  
  	len = sizeof(struct sockaddr_un); //Set our length
  #else //Windows Pipe Code
  	pipe = CreateNamedPipe(path, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, buffer_size, buffer_size, 0, NULL); //Create a message pipe
  
  	if (pipe == INVALID_HANDLE_VALUE) //Make sure it's valid
  	{
! 		std::cout << "sock::sock invalid pipe" << std::endl; //Not valid so output it
  		exit(1); //Then exit
  	}
  #endif
  }
  
  #ifdef _WIN32
  #include <windows.h>
  #include <stdio.h>
--- 74,120 ----
  
  	len = sizeof(struct sockaddr_un); //Set our length
  #else //Windows Pipe Code
+ 	static std::ofstream cerr_file("stderr.txt", std::ios::ate | std::ios::out | std::ios::app);
+     static std::ofstream cout_file("stdout.txt", std::ios::ate | std::ios::out | std::ios::app);
+ 
+     if(cerr_file.is_open()) {
+       cerr_bak = std::cerr.rdbuf();
+       std::cerr.rdbuf(cerr_file.rdbuf());
+     }
+ 
+     if(cout_file.is_open()) {
+       cout_bak = std::cout.rdbuf();
+       std::cout.rdbuf(cout_file.rdbuf());
+     }
+ 	
  	pipe = CreateNamedPipe(path, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, buffer_size, buffer_size, 0, NULL); //Create a message pipe
  
  	if (pipe == INVALID_HANDLE_VALUE) //Make sure it's valid
  	{
! 		std::cout << "Error creating pipe: " << GetLastError() << std::endl; //Not valid so output it
  		exit(1); //Then exit
  	}
  #endif
  }
  
+ //Constructor for stdin
+ SVSSocket::SVSSocket(bool standard_input)
+ {
+ 	if (!standard_input) //If we don't want to use stdin
+ 	{
+ 		::SVSSocket(); //Use our default constructor
+ 		standard_input = false;
+ 	}
+ 	else //Otherwise
+ 	{
+ 		standard_input = true; //Set that we are using stdin
+ 
+ #ifdef _WIN32
+ 		RedirectIOToConsole();
+ #endif
+ 	}
+ }
+ 
  #ifdef _WIN32
  #include <windows.h>
  #include <stdio.h>
***************
*** 160,188 ****
  
  #endif
  
- //Constructor for stdin
- SVSSocket::SVSSocket(bool standard_input)
- {
- 	if (!standard_input) //If we don't want to use stdin
- 		::SVSSocket(); //Use our default constructor
- 	else //Otherwise
- 	{
- 		this->standard_input = true; //Set that we are using stdin
- 
- #ifdef _WIN32
- 		RedirectIOToConsole();
- #endif
- 	}
- }
- 
- SVSSocket::SVSSocket(SVSSocket::socket_type type)
- {
- 	if (type == STDIN)
- 		::SVSSocket(true);
- 	else if (type == SOCKET)
- 		::SVSSocket();
- }
- 
  //Deconstructor
  SVSSocket::~SVSSocket()
  {
--- 198,203 ----
***************
*** 210,218 ****
  		return false; //Return that we had an error
  	}
  #else //On windows
! 	BOOL success = ConnectNamedPipe(pipe, NULL); //Connect to the pipe
  	if (!success) //But if we had an error
  	{
  		CloseHandle(pipe); //Close the pipe
  		return false; //Then return that we had an error
  	}
--- 225,234 ----
  		return false; //Return that we had an error
  	}
  #else //On windows
! 	BOOL success = ConnectNamedPipe(pipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); //Connect to the pipe
  	if (!success) //But if we had an error
  	{
+ 		std::cout << "Error waiting for connection pipe: " << GetLastError() << std::endl;
  		CloseHandle(pipe); //Close the pipe
  		return false; //Then return that we had an error
  	}
***************
*** 221,231 ****
--- 237,269 ----
  	return true; //Otherwise return success
  }
  
+ #ifdef _WIN32
+ #include <conio.h>
+ #endif
+ 
+ int SVSSocket::inputAvailible()
+ {
+ #ifdef _WIN32
+ 	return _kbhit();
+ #else
+ 	struct timeval tv;
+ 	fd_set fds;
+ 	tv.tv_sec = 0;
+ 	tv.tv_usec = 0;
+ 	FD_ZERO(&fds);
+ 	FD_SET(STDIN_FILENO, &fds);
+ 	select(STDIN_FILENO+1, &fds, NULL, NULL, &tv);
+ 	return (FD_ISSET(0, &fds));
+ #endif
+ }
+ 
  //Recieve a line from the socket/pipe
  bool SVSSocket::recieve_line(std::string &line)
  {
  	if (standard_input) //Are we using stdin or an actual socket?
  	{
+ 		while (!inputAvailible());
+ 
  		getline(std::cin, line); //Get one line
  
  		//We have no use for recieve_buffer here since we're using getline and only get one line at a time.  getline handles the rest for us along with cin.
***************
*** 266,269 ****
--- 304,323 ----
  		buffer[n] = '\0'; //Make sure our buffer is null terminated
  		recieve_buffer += buffer; //Add the recieved buffer to our storing string
  	}
+ 
+ 	return true;
+ }
+ 
+ void SVSSocket::reopen_pipe()
+ {
+ 	DisconnectNamedPipe(pipe);
+ 	CloseHandle(pipe);
+ 
+ 	pipe = CreateNamedPipe(default_path_pipe, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, buffer_size, buffer_size, 0, NULL); //Create a message pipe
+ 
+ 	if (pipe == INVALID_HANDLE_VALUE) //Make sure it's valid
+ 	{
+ 		std::cout << "Error creating pipe: " << GetLastError() << std::endl; //Not valid so output it
+ 		exit(1); //Then exit
+ 	}
  }
diff -crb viewer/src/SVSSocket.h SVS Viewer/src/SVSSocket.h
*** viewer/src/SVSSocket.h	2012-07-05 12:49:20.000000000 -0400
--- SVS Viewer/src/SVSSocket.h	2012-07-10 17:01:49.000000000 -0400
***************
*** 31,37 ****
  	} socket_type;
  	
  	SVSSocket(const char* path = ""); //Initializes SVSSocket with a path to the Unix Socket, however, on windows the path argument is ignored because on windows it uses pipes.  Ideally you should just leave this to the default which will be set if you leave it to nothing ie. SVSSocket();
- 	SVSSocket(const char* path = "");
  	SVSSocket(bool standard_input); //Used for standard input
  	SVSSocket(socket_type type);
  	
--- 31,36 ----
***************
*** 40,45 ****
--- 39,52 ----
  	bool listen(); //Accept a connection.  Warning, this is a *blocking* call which means it won't return until it has a connection
  	bool recieve_line(std::string &line); //Read a line from the buffer.  Again, Warning, this is a *blocking* call which means it won't return until it has something to return
  	
+ 	bool is_standard_input() { return standard_input; }
+ 
+ 	bool client_disconnected() { return GetLastError() == ERROR_BROKEN_PIPE; }
+ 
+ #ifdef _WIN32
+ 	void reopen_pipe();
+ #endif
+ 
  private:
  	std::string recieve_buffer; //Buffer to handle input
  	
***************
*** 57,69 ****
  
  #ifdef _WIN32
  	void RedirectIOToConsole();
  #endif
  	
  	void initialize_stdin();
  	void initialize_socket(const char* path);
  	void initialize_file(const char* path);
  	
! 	std::string hello_world;
  };
  
  #endif
--- 64,79 ----
  
  #ifdef _WIN32
  	void RedirectIOToConsole();
+ 
+ 	std::streambuf* cout_bak;
+ 	std::streambuf* cerr_bak;
  #endif
  	
  	void initialize_stdin();
  	void initialize_socket(const char* path);
  	void initialize_file(const char* path);
  	
! 	static int inputAvailible();
  };
  
  #endif
diff -crb viewer/src/SVSViewerState.cpp SVS Viewer/src/SVSViewerState.cpp
*** viewer/src/SVSViewerState.cpp	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSViewerState.cpp	2012-07-12 14:43:51.000000000 -0400
***************
*** 16,35 ****
  
  #include "SVSParser.h"
  
- #ifdef _WIN32
- #include <conio.h>
- #endif
- 
  int thread_runner(void* viewer)
  {
  	return reinterpret_cast<SVSViewerState*>(viewer)->reader_function();
  }
  
  SVSViewerState::SVSViewerState(SVSSocket::socket_type type)
! : reader_socket(type),
! max_velo(50.0f, 50.0f, 50.0f),
! max_time_step(1.0f / 20.0f),
! max_time_steps(10.0f)
  {
  	set_pausable(false); //Make sure we cannot pause the viewer because that would be bad.
  	
--- 16,30 ----
  
  #include "SVSParser.h"
  
  int thread_runner(void* viewer)
  {
  	return reinterpret_cast<SVSViewerState*>(viewer)->reader_function();
  }
  
  SVSViewerState::SVSViewerState(SVSSocket::socket_type type)
! 	: max_velo(SVSObject::global_scale * 5, SVSObject::global_scale * 5, SVSObject::global_scale * 5),
! 	max_time_step(1.0f / 20.0f),
! 	max_time_steps(10.0f)
  {
  	set_pausable(false); //Make sure we cannot pause the viewer because that would be bad.
  
***************
*** 37,42 ****
--- 32,47 ----
  
  	mu = SDL_CreateMutex();
  
+ 	if (type == SVSSocket::STDIN)
+ 		reader_socket = new SVSSocket(true);
+ 	else if (type == SVSSocket::SOCKET)
+ 		reader_socket = new SVSSocket();
+ 	else
+ 	{
+ 		std::cout << "Invalid type: " << type << std::endl;
+ 		exit(1);
+ 	}
+ 
  	reader_thread = SDL_CreateThread(thread_runner, this);
  
  	movement.left = false;
***************
*** 46,55 ****
  	movement.plus = false;
  	movement.minus = false;
  	
! 	camera.far_clip = 5000.0f;
  	
  	grid = true;
  	wireframe = true;
  }
  
  SVSViewerState::~SVSViewerState()
--- 51,63 ----
  	movement.plus = false;
  	movement.minus = false;
  
! 	camera.far_clip = 15000.0f;
! 	camera.near_clip = 1.0f;
  
  	grid = true;
  	wireframe = true;
+ 
+ 	button1_down = false;
  }
  
  SVSViewerState::~SVSViewerState()
***************
*** 60,104 ****
  	SDL_DestroyMutex(mu);
  }
  
! int SVSViewerState::inputAvailible()
  {
  #ifdef _WIN32
! 	return _kbhit();
! #else
! 	struct timeval tv;
! 	fd_set fds;
! 	tv.tv_sec = 0;
! 	tv.tv_usec = 0;
! 	FD_ZERO(&fds);
! 	FD_SET(STDIN_FILENO, &fds);
! 	select(STDIN_FILENO+1, &fds, NULL, NULL, &tv);
! 	return (FD_ISSET(0, &fds));
  #endif
- }
  
! bool SVSViewerState::reader_function()
! {
! 	std::string line;
  	
! 	while (reader_socket.listen() && !should_die)
  	{
  		std::cout << "Got a connection" << std::endl;
  		
  		while (!should_die)
  		{
! 			if (inputAvailible())
! 			{
! 				getline(std::cin, line);
! 				if (line.find_first_not_of("\t\n ") != std::string::npos)
! 				{
  					SDL_mutexP(mu);
  					reader_buffer.push_back(line);
! 					SDL_mutexV(mu);
! 				}
  			}
  		}
  		
  		std::cout << "Client (SVS) disconnected" << std::endl;
  	}
  	
  	return true;
--- 68,128 ----
  	SDL_DestroyMutex(mu);
  }
  
! bool SVSViewerState::reader_function()
  {
+ 	std::string line;
+ 
+ 	while (!should_die)
+ 	{
+ 
+ 		bool reopened_pipe = false;
+ 
+ 		SDL_mutexP(mu);
+ 		if (scenes.size() > 0)
+ 		{
  #ifdef _WIN32
! 			reader_socket->reopen_pipe();
  #endif
  
! 			reopened_pipe = true;
! 		}
! 		SDL_mutexV(mu);
! 
! 		if (!reader_socket->listen())
! 			return false;
  
! 		if (reopened_pipe && scenes.size() > 0)
  		{
+ 			SDL_mutexP(mu);
+ 			scenes[0].clear_objects();
+ 			SDL_mutexV(mu);
+ 		}
+ 
+ 		SDL_mutexP(mu);
  		std::cout << "Got a connection" << std::endl;
+ 		SDL_mutexV(mu);
  		
  		while (!should_die)
  		{
! 			reader_socket->recieve_line(line);
! 			if (reader_socket->client_disconnected())
! 				break;
! 
  			SDL_mutexP(mu);
+ 			std::cout << "Recieved: '" << line << "'" << std::endl;
+ 			
+ 			if (line.find_first_not_of("\t\n ") != std::string::npos && line.size() != 0)
+ 			{
  				reader_buffer.push_back(line);
! 				line = "";
  			}
+ 			SDL_mutexV(mu);
  		}
  
+ 		SDL_mutexP(mu);
  		std::cout << "Client (SVS) disconnected" << std::endl;
+ 		SDL_mutexV(mu);
+ 
  	}
  
  	return true;
***************
*** 160,165 ****
--- 184,192 ----
  		std::istream_iterator<std::string>(),
  		std::back_inserter<std::vector<std::string> >(parts));
  
+ 	if (parts.size() == 1 && parts[0] == "clear")
+ 		return true;
+ 
  	if (parts.size() < 3)
  		return false;
  
***************
*** 186,192 ****
--- 213,221 ----
  		scenes.push_back(new_scene);
  		scene_number = scenes.size()-1;
  
+ 		SDL_mutexP(mu);
  		std::cout << "Warning: Created new scene: '" << scene_name << "'" << std::endl;
+ 		SDL_mutexV(mu);
  	}
  
  	std::vector<std::string> subvector(parts.begin()+2, parts.end());
***************
*** 217,235 ****
  }
  
  void SVSViewerState::on_push() {
! 	Zeni::get_Window().mouse_hide(true);
! 	Zeni::get_Window().mouse_grab(true);
  	
  	set_pausable(false);
  	
! 	mouse_grabbed = true;
  }
  
  void SVSViewerState::on_pop() {
! 	Zeni::get_Window().mouse_grab(false);
  	Zeni::get_Window().mouse_hide(false);
  	
! 	mouse_grabbed = false;
  }
  
  void SVSViewerState::on_key(const SDL_KeyboardEvent &event)
--- 246,264 ----
  }
  
  void SVSViewerState::on_push() {
! 	/*Zeni::get_Window().mouse_hide(true);
! 	Zeni::get_Window().mouse_grab(true);*/
  
  	set_pausable(false);
  
! 	//mouse_grabbed = true;
  }
  
  void SVSViewerState::on_pop() {
! 	/*Zeni::get_Window().mouse_grab(false);
  	Zeni::get_Window().mouse_hide(false);
  
! 	mouse_grabbed = false;*/
  }
  
  void SVSViewerState::on_key(const SDL_KeyboardEvent &event)
***************
*** 298,304 ****
  			exit(1);
  			break;
  		}
! 		case SDLK_u:
  		{
  			if (mouse_grabbed)
  			{
--- 327,395 ----
  			exit(1);
  			break;
  		}
! 	case SDLK_PERIOD:
! 		{
! 			if (event.type != SDL_KEYDOWN)
! 				break;
! 
! 			if (max_velo.x >= SVSObject::global_scale * 10)
! 				break;
! 
! 			max_velo.x += SVSObject::global_scale;
! 			max_velo.y += SVSObject::global_scale;
! 			max_velo.z += SVSObject::global_scale;
! 
! 			break;
! 		}
! 	case SDLK_COMMA:
! 		{
! 			if (event.type != SDL_KEYDOWN)
! 				break;
! 
! 			if (max_velo.x <= SVSObject::global_scale)
! 				break;
! 
! 			max_velo.x -= SVSObject::global_scale;
! 			max_velo.y -= SVSObject::global_scale;
! 			max_velo.z -= SVSObject::global_scale;
! 
! 			break;
! 		}
! 	case SDLK_LSHIFT:
! 	case SDLK_RSHIFT:
! 	case SDLK_SLASH:
! 		{
! 			if (max_velo.x >= SVSObject::global_scale * 20)
! 			{
! 				max_velo = backup_speed;
! 			}
! 			else
! 			{
! 				backup_speed = max_velo;
! 
! 				max_velo.x = SVSObject::global_scale * 20;
! 				max_velo.y = SVSObject::global_scale * 20;
! 				max_velo.z = SVSObject::global_scale * 20;
! 			}
! 			break;
! 		}
! 	case SDLK_SPACE:
! 		{
! 			if (max_velo.x <= SVSObject::global_scale / 10.0f)
! 			{
! 				max_velo = backup_speed;
! 			}
! 			else
! 			{
! 				backup_speed = max_velo;
! 
! 				max_velo.x = SVSObject::global_scale / 10.0f;
! 				max_velo.y = SVSObject::global_scale / 10.0f;
! 				max_velo.z = SVSObject::global_scale / 10.0f;
! 			}
! 			break;
! 		}
! 		/*case SDLK_u:
  		{
  		if (mouse_grabbed)
  		{
***************
*** 311,324 ****
  				Zeni::get_Window().mouse_hide(true);
  			}
  			break;
! 		}
  			
  		default:
  			Gamestate_Base::on_key(event);
  	}
  }
  
! void SVSViewerState::on_mouse_motion(const SDL_MouseMotionEvent &event) {	
  	camera.turn_left_xy(-event.xrel / 100.0f);
  	
  	// Back up a couple vectors
--- 402,425 ----
  		Zeni::get_Window().mouse_hide(true);
  		}
  		break;
! 		}*/
  
  	default:
  		Gamestate_Base::on_key(event);
  	}
  }
  
! void SVSViewerState::on_mouse_button(const SDL_MouseButtonEvent &event)
! {
! 	if (event.button == SDL_BUTTON_LEFT)
! 		button1_down = event.type == SDL_MOUSEBUTTONDOWN;
! }
! 
! void SVSViewerState::on_mouse_motion(const SDL_MouseMotionEvent &event)
! {
! 	if (!button1_down)
! 		return;
! 
  	camera.turn_left_xy(-event.xrel / 100.0f);
  
  	// Back up a couple vectors
***************
*** 337,356 ****
  		camera.orientation = prev_orientation;
  }
  
! void SVSViewerState::draw_grid(float xstart, float ystart, int rows, int columns, int distance)
  {
- 	int extra_lines_x = (int) xstart/distance;
- 	int extra_lines_y = (int) ystart/distance;
- 	
  	glBegin(GL_LINES);
!     for (int i = 0; i <= rows + extra_lines_x; i++) {
! 		glVertex2f(xstart, i * distance + ystart);
! 		glVertex2f((float) columns, i * distance + ystart);
      }
  	
!     for (int i= 0; i <= columns + extra_lines_y; i++) {
! 		glVertex2f(i * distance + xstart, ystart);
! 		glVertex2f(i * distance + xstart, (float) rows);
      }
  	glEnd();
  }
--- 438,454 ----
  		camera.orientation = prev_orientation;
  }
  
! void SVSViewerState::draw_grid(float xstart, float ystart, int rows, int columns, float distance_x, float distance_y)
  {
  	glBegin(GL_LINES);
! 	for (int i = 0; i <= rows; i++) {
! 		glVertex2f(xstart, i * distance_y);
! 		glVertex2f(xstart + columns * distance_x, i * distance_y);
  	}
  
! 	for (int i= 0; i <= columns; i++) {
! 		glVertex2f(i * distance_x, ystart);
! 		glVertex2f(i * distance_x, ystart + rows * distance_y);
  	}
  	glEnd();
  }
***************
*** 365,371 ****
  	if (grid)
  	{
  		glColor3f(1.0f, 1.0f, 1.0f);
! 		draw_grid(-4000.0f, -4000.0f, 8000, 8000);
  	}
  	
  	if (wireframe)
--- 463,469 ----
  	if (grid)
  	{
  		glColor3f(1.0f, 1.0f, 1.0f);
! 		draw_grid(0.0f, 0.0f, 256, 256, SVSObject::global_scale, SVSObject::global_scale * -1);
  	}
  
  	if (wireframe)
***************
*** 375,393 ****
--- 473,503 ----
  		glPolygonOffset(1, 1);
  
  		if (scenes.size() > 0)
+ 		{
+ 			SDL_mutexP(mu);
  			scenes[0].render();
+ 			SDL_mutexV(mu);
+ 		}
  
  		glDisable(GL_POLYGON_OFFSET_FILL);
  
  		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  
  		if (scenes.size() > 0)
+ 		{
+ 			SDL_mutexP(mu);
  			scenes[0].render_wireframe();
+ 			SDL_mutexV(mu);
+ 		}
  	}
  	else
  	{
  		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  		if (scenes.size() > 0)
+ 		{
+ 			SDL_mutexP(mu);
  			scenes[0].render();
+ 			SDL_mutexV(mu);
+ 		}
  	}
  }
diff -crb viewer/src/SVSViewerState.h SVS Viewer/src/SVSViewerState.h
*** viewer/src/SVSViewerState.h	2012-07-05 12:48:33.000000000 -0400
--- SVS Viewer/src/SVSViewerState.h	2012-07-12 12:03:07.000000000 -0400
***************
*** 24,31 ****
  	SVSViewerState(SVSSocket::socket_type type);
  	~SVSViewerState();
  	
- 	static int inputAvailible();
- 	
  	bool reader_function();
  	
  	bool parse_command(std::string command);
--- 24,29 ----
***************
*** 37,52 ****
  	void on_key(const SDL_KeyboardEvent &event);
  	
  	void on_mouse_motion(const SDL_MouseMotionEvent &event);
  	
  	void on_push();
  	void on_pop();
  	
  private:
  	std::vector<std::string> reader_buffer;
  	
! 	SVSSocket reader_socket;
  	
- 	SDL_mutex *mu;
  	SDL_Thread* reader_thread;
  	
  	std::vector<SVSScene> scenes;
--- 35,54 ----
  	void on_key(const SDL_KeyboardEvent &event);
  	
  	void on_mouse_motion(const SDL_MouseMotionEvent &event);
+ 	void on_mouse_button(const SDL_MouseButtonEvent &event);
  	
  	void on_push();
  	void on_pop();
  
+ 	bool button1_down;
+ 
+ 	SDL_mutex *mu;
+ 	
  private:
  	std::vector<std::string> reader_buffer;
  	
! 	SVSSocket *reader_socket;
  	
  	SDL_Thread* reader_thread;
  	
  	std::vector<SVSScene> scenes;
***************
*** 72,83 ****
  	float max_time_steps;
  	Zeni::Vector3f max_velo;
  	
! 	void draw_grid(float xstart, float ystart, int rows, int columns, int distance = 50);
  	
  	bool grid;
  	bool wireframe;
  	
  	bool mouse_grabbed;
  };
  
  #endif
--- 74,87 ----
  	float max_time_steps;
  	Zeni::Vector3f max_velo;
  	
! 	void draw_grid(float xstart, float ystart, int rows, int columns, float distance_x, float distance_y);
  	
  	bool grid;
  	bool wireframe;
  	
  	bool mouse_grabbed;
+ 
+ 	Zeni::Point3f backup_speed;
  };
  
  #endif
diff -crb viewer/stdout.txt SVS Viewer/stdout.txt
*** viewer/stdout.txt	2012-07-05 12:33:56.000000000 -0400
--- SVS Viewer/stdout.txt	2012-07-12 14:44:54.000000000 -0400
***************
*** 1 ****
--- 1,300 ----
  Initializing OpenGL
+ Got a connection
+ Recieved: 'clear'
+ Recieved: 'S1 a -x0 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p  0 -1  0 r 0 0 0 s 129 1 1'
+ Warning: Created new scene: 'S1'
+ Position: 0,50,0
+ Scale: 129,-1,1
+ Local Matrix: 
+ 129 0 0 0
+ 0 -1 0 50
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ 6450 0 0 0
+ 0 -50 0 50
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 6450,50,0
+ Corner (1): 6450,0,0
+ Corner (1): 0,0,0
+ Corner (1): 0,50,0
+ Corner (2): 0,50,50
+ Corner (2): 6450,50,50
+ Corner (2): 6450,50,0
+ Corner (2): 0,50,0
+ Corner (3): 6450,50,50
+ Corner (3): 6450,0,50
+ Corner (3): 6450,0,0
+ Corner (3): 6450,50,0
+ Corner (4): 0,0,50
+ Corner (4): 0,50,50
+ Corner (4): 0,50,0
+ Corner (4): 0,0,0
+ Corner (5): 6450,0,50
+ Corner (5): 0,0,50
+ Corner (5): 0,0,0
+ Corner (5): 6450,0,0
+ Corner (6): 0,0,50
+ Corner (6): 6450,0,50
+ Corner (6): 6450,50,50
+ Corner (6): 0,50,50
+ Recieved: 'S1 a x0 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p   0 129   0 r 0 0 0 s 129 1 1'
+ Recieved: 'S1 a -y0 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p -1 0 0 r 0 0 0 s   1 129   1'
+ Recieved: 'S1 a y0 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p 129 0 0 r 0 0 0 s   1 129   1'
+ Recieved: 'S1 a TerranSCV1 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p   8 122   0 r       0 4.71239       0 s 1 1 1'
+ Recieved: 'S1 a TerranSCV2 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p   7 122   0 r       0 1.76715       0 s 1 1 1'
+ Recieved: 'S1 a TerranSCV3 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p   6 122   0 r       0 4.31969       0 s 1 1 1'
+ Recieved: 'S1 a TerranSCV4 world v 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1  p   6 122   0 r       0 4.31969       0 s 1 1 1'
+ Position: 0,-6450,0
+ Scale: 129,-1,1
+ Local Matrix: 
+ 129 0 0 0
+ 0 -1 0 -6450
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ 6450 0 0 0
+ 0 -50 0 -6450
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 6450,-6450,0
+ Corner (1): 6450,-6500,0
+ Corner (1): 0,-6500,0
+ Corner (1): 0,-6450,0
+ Corner (2): 0,-6450,50
+ Corner (2): 6450,-6450,50
+ Corner (2): 6450,-6450,0
+ Corner (2): 0,-6450,0
+ Corner (3): 6450,-6450,50
+ Corner (3): 6450,-6500,50
+ Corner (3): 6450,-6500,0
+ Corner (3): 6450,-6450,0
+ Corner (4): 0,-6500,50
+ Corner (4): 0,-6450,50
+ Corner (4): 0,-6450,0
+ Corner (4): 0,-6500,0
+ Corner (5): 6450,-6500,50
+ Corner (5): 0,-6500,50
+ Corner (5): 0,-6500,0
+ Corner (5): 6450,-6500,0
+ Corner (6): 0,-6500,50
+ Corner (6): 6450,-6500,50
+ Corner (6): 6450,-6450,50
+ Corner (6): 0,-6450,50
+ Position: -50,-0,0
+ Scale: 1,-129,1
+ Local Matrix: 
+ 1 0 0 -50
+ 0 -129 0 0
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ 50 0 0 -50
+ 0 -6450 0 0
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 0,0,0
+ Corner (1): 0,-6450,0
+ Corner (1): -50,-6450,0
+ Corner (1): -50,0,0
+ Corner (2): -50,0,50
+ Corner (2): 0,0,50
+ Corner (2): 0,0,0
+ Corner (2): -50,0,0
+ Corner (3): 0,0,50
+ Corner (3): 0,-6450,50
+ Corner (3): 0,-6450,0
+ Corner (3): 0,0,0
+ Corner (4): -50,-6450,50
+ Corner (4): -50,0,50
+ Corner (4): -50,0,0
+ Corner (4): -50,-6450,0
+ Corner (5): 0,-6450,50
+ Corner (5): -50,-6450,50
+ Corner (5): -50,-6450,0
+ Corner (5): 0,-6450,0
+ Corner (6): -50,-6450,50
+ Corner (6): 0,-6450,50
+ Corner (6): 0,0,50
+ Corner (6): -50,0,50
+ Position: 6450,-0,0
+ Scale: 1,-129,1
+ Local Matrix: 
+ 1 0 0 6450
+ 0 -129 0 0
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ 50 0 0 6450
+ 0 -6450 0 0
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 6500,0,0
+ Corner (1): 6500,-6450,0
+ Corner (1): 6450,-6450,0
+ Corner (1): 6450,0,0
+ Corner (2): 6450,0,50
+ Corner (2): 6500,0,50
+ Corner (2): 6500,0,0
+ Corner (2): 6450,0,0
+ Corner (3): 6500,0,50
+ Corner (3): 6500,-6450,50
+ Corner (3): 6500,-6450,0
+ Corner (3): 6500,0,0
+ Corner (4): 6450,-6450,50
+ Corner (4): 6450,0,50
+ Corner (4): 6450,0,0
+ Corner (4): 6450,-6450,0
+ Corner (5): 6500,-6450,50
+ Corner (5): 6450,-6450,50
+ Corner (5): 6450,-6450,0
+ Corner (5): 6500,-6450,0
+ Corner (6): 6450,-6450,50
+ Corner (6): 6500,-6450,50
+ Corner (6): 6500,0,50
+ Corner (6): 6450,0,50
+ Position: 400,-6100,0
+ Scale: 1,-1,1
+ Local Matrix: 
+ 1.04575e-006 -1 0 400
+ -1 -1.04575e-006 0 -6100
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ 5.22876e-005 -50 0 400
+ -50 -5.22876e-005 0 -6100
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 400,-6150,0
+ Corner (1): 350,-6150,0
+ Corner (1): 350,-6100,0
+ Corner (1): 400,-6100,0
+ Corner (2): 400,-6100,50
+ Corner (2): 400,-6150,50
+ Corner (2): 400,-6150,0
+ Corner (2): 400,-6100,0
+ Corner (3): 400,-6150,50
+ Corner (3): 350,-6150,50
+ Corner (3): 350,-6150,0
+ Corner (3): 400,-6150,0
+ Corner (4): 350,-6100,50
+ Corner (4): 400,-6100,50
+ Corner (4): 400,-6100,0
+ Corner (4): 350,-6100,0
+ Corner (5): 350,-6150,50
+ Corner (5): 350,-6100,50
+ Corner (5): 350,-6100,0
+ Corner (5): 350,-6150,0
+ Corner (6): 350,-6100,50
+ Corner (6): 350,-6150,50
+ Corner (6): 400,-6150,50
+ Corner (6): 400,-6100,50
+ Position: 350,-6100,0
+ Scale: 1,-1,1
+ Local Matrix: 
+ -0.195094 0.980784 0 350
+ 0.980784 0.195094 0 -6100
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ -9.75472 49.0392 0 350
+ 49.0392 9.75472 0 -6100
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 340.245,-6050.96,0
+ Corner (1): 389.284,-6041.21,0
+ Corner (1): 399.039,-6090.25,0
+ Corner (1): 350,-6100,0
+ Corner (2): 350,-6100,50
+ Corner (2): 340.245,-6050.96,50
+ Corner (2): 340.245,-6050.96,0
+ Corner (2): 350,-6100,0
+ Corner (3): 340.245,-6050.96,50
+ Corner (3): 389.284,-6041.21,50
+ Corner (3): 389.284,-6041.21,0
+ Corner (3): 340.245,-6050.96,0
+ Corner (4): 399.039,-6090.25,50
+ Corner (4): 350,-6100,50
+ Corner (4): 350,-6100,0
+ Corner (4): 399.039,-6090.25,0
+ Corner (5): 389.284,-6041.21,50
+ Corner (5): 399.039,-6090.25,50
+ Corner (5): 399.039,-6090.25,0
+ Corner (5): 389.284,-6041.21,0
+ Corner (6): 399.039,-6090.25,50
+ Corner (6): 389.284,-6041.21,50
+ Corner (6): 340.245,-6050.96,50
+ Corner (6): 350,-6100,50
+ Position: 300,-6100,0
+ Scale: 1,-1,1
+ Local Matrix: 
+ -0.382683 -0.92388 0 300
+ -0.92388 0.382683 0 -6100
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ -19.1342 -46.194 0 300
+ -46.194 19.1342 0 -6100
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 280.866,-6146.19,0
+ Corner (1): 234.672,-6127.06,0
+ Corner (1): 253.806,-6080.87,0
+ Corner (1): 300,-6100,0
+ Corner (2): 300,-6100,50
+ Corner (2): 280.866,-6146.19,50
+ Corner (2): 280.866,-6146.19,0
+ Corner (2): 300,-6100,0
+ Corner (3): 280.866,-6146.19,50
+ Corner (3): 234.672,-6127.06,50
+ Corner (3): 234.672,-6127.06,0
+ Corner (3): 280.866,-6146.19,0
+ Corner (4): 253.806,-6080.87,50
+ Corner (4): 300,-6100,50
+ Corner (4): 300,-6100,0
+ Corner (4): 253.806,-6080.87,0
+ Corner (5): 234.672,-6127.06,50
+ Corner (5): 253.806,-6080.87,50
+ Corner (5): 253.806,-6080.87,0
+ Corner (5): 234.672,-6127.06,0
+ Corner (6): 253.806,-6080.87,50
+ Corner (6): 234.672,-6127.06,50
+ Corner (6): 280.866,-6146.19,50
+ Corner (6): 300,-6100,50
+ Position: 300,-6100,0
+ Scale: 1,-1,1
+ Local Matrix: 
+ -0.382683 -0.92388 0 300
+ -0.92388 0.382683 0 -6100
+ 0 0 1 0
+ 0 0 0 1
+ Final Matrix: 
+ -19.1342 -46.194 0 300
+ -46.194 19.1342 0 -6100
+ 0 0 50 0
+ 0 0 0 1
+ Corner (1): 280.866,-6146.19,0
+ Corner (1): 234.672,-6127.06,0
+ Corner (1): 253.806,-6080.87,0
+ Corner (1): 300,-6100,0
+ Corner (2): 300,-6100,50
+ Corner (2): 280.866,-6146.19,50
+ Corner (2): 280.866,-6146.19,0
+ Corner (2): 300,-6100,0
+ Corner (3): 280.866,-6146.19,50
+ Corner (3): 234.672,-6127.06,50
+ Corner (3): 234.672,-6127.06,0
+ Corner (3): 280.866,-6146.19,0
+ Corner (4): 253.806,-6080.87,50
+ Corner (4): 300,-6100,50
+ Corner (4): 300,-6100,0
+ Corner (4): 253.806,-6080.87,0
+ Corner (5): 234.672,-6127.06,50
+ Corner (5): 253.806,-6080.87,50
+ Corner (5): 253.806,-6080.87,0
+ Corner (5): 234.672,-6127.06,0
+ Corner (6): 253.806,-6080.87,50
+ Corner (6): 234.672,-6127.06,50
+ Corner (6): 280.866,-6146.19,50
+ Corner (6): 300,-6100,50
